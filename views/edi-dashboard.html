<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EDI Management System - Forecast</title>
    <link rel="stylesheet" href="/css/style.css">
    <style>
        /* Tab System Styles */
        .product-tabs {
            display: flex;
            background: #f8fafc;
            border-bottom: 2px solid #e5e7eb;
            border-radius: 10px 10px 0 0;
            overflow-x: auto;
            margin-bottom: 0;
        }

        .product-tab {
            padding: 15px 25px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            white-space: nowrap;
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease;
            min-width: 200px;
            text-align: center;
        }

        .product-tab:hover {
            background: #e5e7eb;
        }

        .product-tab.active {
            background: white;
            border-bottom-color: #4f46e5;
            color: #4f46e5;
        }

        .product-tab .tab-code {
            display: block;
            font-size: 16px;
            font-weight: 700;
            margin-bottom: 3px;
        }

        .product-tab .tab-name {
            display: block;
            font-size: 12px;
            opacity: 0.7;
        }

        .tab-content {
            display: none;
            background: white;
            border: 1px solid #e5e7eb;
            border-top: none;
            border-radius: 0 0 10px 10px;
            padding: 30px;
            min-height: 600px;
        }

        .tab-content.active {
            display: block;
        }

        /* Forecast Table Styles */
        .forecast-table {
            width: 100%;
            overflow-x: auto;
            margin-bottom: 30px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            border-radius: 12px;
        }

        .forecast-table table {
            width: 100%;
            min-width: 800px;
            font-size: 0.95rem;
            border-collapse: collapse;
            background: white;
        }

        .forecast-table th {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            color: white;
            text-align: center;
            padding: 15px 12px;
            font-weight: 600;
            white-space: nowrap;
        }

        .forecast-table th:first-child {
            background: linear-gradient(135deg, #1f2937 0%, #374151 100%);
            min-width: 120px;
        }

        .forecast-table td {
            padding: 12px;
            border-bottom: 1px solid #e5e7eb;
            text-align: center;
        }

        .forecast-table td:first-child {
            background: #f8fafc;
            font-weight: 700;
            text-align: left;
            color: #374151;
        }

        .forecast-table tr:hover td:not(:first-child) {
            background: #f0f4ff;
        }

        .forecast-input {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #d1d5db;
            border-radius: 6px;
            text-align: center;
            font-size: 16px;
            background: white;
            font-weight: 600;
            transition: all 0.3s ease;
            min-width: 80px;
        }

        .forecast-input:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
            background: #fefefe;
        }

        .forecast-input:disabled {
            background: #f3f4f6;
            color: #6b7280;
            cursor: not-allowed;
        }

        .forecast-input.changed {
            background: #fef3c7;
            border-color: #f59e0b;
        }

        .month-header {
            text-align: center;
            font-size: 0.9rem;
            line-height: 1.3;
            padding: 15px 8px;
        }

        .month-japanese {
            font-size: 16px;
            font-weight: 700;
            margin-bottom: 4px;
            color: white;
        }

        .month-english {
            font-size: 11px;
            opacity: 0.9;
            color: rgba(255, 255, 255, 0.8);
        }

        .month-date {
            font-size: 10px;
            opacity: 0.8;
            color: rgba(255, 255, 255, 0.7);
            margin-top: 2px;
        }

        /* Product Summary */
        .product-summary {
            background: linear-gradient(135deg, #f8fafc 0%, #e5e7eb 100%);
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 25px;
        }

        .product-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .product-details h3 {
            margin: 0;
            color: #1f2937;
            font-size: 1.4rem;
        }

        .product-details p {
            margin: 5px 0 0 0;
            color: #6b7280;
            font-size: 0.95rem;
        }

        .product-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .stat-item {
            text-align: center;
            padding: 15px;
            background: white;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
        }

        .stat-number {
            font-size: 1.5rem;
            font-weight: 700;
            color: #4f46e5;
            margin-bottom: 5px;
        }

        .stat-label {
            color: #6b7280;
            font-size: 0.9rem;
            font-weight: 500;
        }

        /* Controls */
        .forecast-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 25px;
            flex-wrap: wrap;
            background: #f8fafc;
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #e5e7eb;
        }

        .btn {
            padding: 10px 18px;
            border-radius: 8px;
            border: 1px solid;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .btn:disabled {
            cursor: not-allowed;
            transform: none;
            opacity: 0.6;
        }

        .btn-primary {
            background: #4f46e5;
            border-color: #4338ca;
            color: white;
        }

        .btn-success {
            background: #059669;
            border-color: #047857;
            color: white;
        }

        .btn-warning {
            background: #f59e0b;
            border-color: #d97706;
            color: white;
        }

        .btn-secondary {
            background: #6b7280;
            border-color: #4b5563;
            color: white;
        }

        .save-status {
            margin-left: auto;
            font-size: 0.9rem;
            color: #6b7280;
            font-weight: 500;
        }

        .save-status.saving {
            color: #f59e0b;
        }

        .save-status.saved {
            color: #059669;
        }

        .save-status.error {
            color: #dc2626;
        }

        .admin-only.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 40px;
            color: #6b7280;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #4f46e5;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .message {
            padding: 12px 18px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-weight: 500;
        }

        .message.success {
            background: #d1fae5;
            border: 1px solid #10b981;
            color: #065f46;
        }

        .message.error {
            background: #fee2e2;
            border: 1px solid #ef4444;
            color: #991b1b;
        }

        .message.info {
            background: #dbeafe;
            border: 1px solid #3b82f6;
            color: #1e40af;
        }

        .message.warning {
            background: #fef3c7;
            border: 1px solid #f59e0b;
            color: #92400e;
        }

        @media (max-width: 768px) {
            .product-tabs {
                flex-direction: column;
            }
            
            .product-tab {
                min-width: auto;
                text-align: left;
            }
            
            .forecast-controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .product-info {
                flex-direction: column;
                align-items: stretch;
                text-align: center;
            }
            
            .forecast-table th, .forecast-table td {
                padding: 8px 6px;
                font-size: 0.85rem;
            }
            
            .forecast-input {
                padding: 8px 10px;
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <nav class="navbar">
        <div class="nav-brand">
            <h2>EDI Management System</h2>
        </div>
        <div class="nav-links">
            <a href="/pages/page1">Page 1</a>
            <a href="/pages/page2">Page 2</a>
            <a href="/pages/page3">Page 3</a>
            <a href="/edi/dashboard">EDI Dashboard</a>
            <a href="/forecast/dashboard" class="active">üìà Forecast</a>
        </div>
        <div class="nav-user">
            <span class="username">Welcome, <span id="current-user">admin</span></span>
            <button class="logout-btn" onclick="logout()">Logout</button>
        </div>
    </nav>

    <main class="main-content">
        <div class="page-header">
            <h1>üìà Monthly Production Forecast</h1>
            <p>Manage monthly forecast quantities by product code - aligned with delivery dates</p>
        </div>

        <div id="messageContainer"></div>
        <div class="loading" id="loadingIndicator">
            <div class="spinner"></div>
            Loading forecast data...
        </div>

        <!-- Forecast Controls -->
        <div class="forecast-controls">
            <button class="btn btn-primary admin-only" id="saveAllBtn" onclick="saveAllForecasts()">
                üíæ Save All Changes
            </button>
            <button class="btn btn-success" id="refreshBtn" onclick="refreshForecastData()">
                üîÑ Refresh Data
            </button>
            <button class="btn btn-warning admin-only" onclick="clearAllData()">
                üóëÔ∏è Clear All Data
            </button>
            <button class="btn btn-secondary" onclick="showDebugInfo()">
                üîç Debug Info
            </button>
            <div class="save-status" id="saveStatus">Ready</div>
        </div>

        <!-- Product Tabs -->
        <div class="product-tabs" id="productTabs">
            <!-- Tabs will be generated dynamically -->
        </div>

        <!-- Tab Contents -->
        <div id="tabContents">
            <!-- Tab contents will be generated dynamically -->
        </div>
    </main>

    <script src="/js/main.js"></script>
    <script>
        class ForecastManager {
            constructor() {
                this.currentUser = null;
                this.userPermissions = { canEdit: false, canView: true };
                this.forecastData = {};
                this.changedCells = new Set();
                this.months = [];
                this.activeProductCode = null;
                
                // 7 Product codes with Japanese names
                this.products = [
                    { code: 'PP4166-4681P003', name: 'ÔΩ±ÔΩØÔæäÔæüÔæåÔæûÔæöÔΩ∞Ôæë', color: '#e74c3c' },
                    { code: 'PP4166-4681P004', name: 'ÔΩ±ÔΩØÔæäÔæüÔæåÔæûÔæöÔΩ∞Ôæë', color: '#c0392b' },
                    { code: 'PP4166-4726P003', name: 'ÔæÑÔΩØÔæåÔæüÔæåÔæüÔæöÔΩ∞ÔæÑ', color: '#2ecc71' },
                    { code: 'PP4166-4726P004', name: 'ÔæÑÔΩØÔæåÔæüÔæåÔæüÔæöÔΩ∞ÔæÑ', color: '#27ae60' },
                    { code: 'PP4166-4731P002', name: 'ÔæêÔæÑÔæûÔæôÔæåÔæöÔΩ∞Ôæë', color: '#3498db' },
                    { code: 'PP4166-7106P001', name: 'ÔæêÔæÑÔæûÔæôÔæåÔæöÔΩ∞Ôæë', color: '#2980b9' },
                    { code: 'PP4166-7106P003', name: 'ÔæêÔæÑÔæûÔæôÔæåÔæöÔΩ∞Ôæë', color: '#1abc9c' }
                ];
            }

            // Generate 12 months starting from current month with actual dates
            generateMonths() {
                const months = [];
                const now = new Date();
                
                for (let i = 0; i < 12; i++) {
                    const date = new Date(now.getFullYear(), now.getMonth() + i, 1);
                    const year = date.getFullYear();
                    const month = date.getMonth() + 1;
                    
                    // Use actual date format YYYY-MM-01 for delivery alignment
                    const dateKey = `${year}-${String(month).padStart(2, '0')}-01`;
                    
                    // Japanese month names
                    const japaneseMonths = ['1Êúà', '2Êúà', '3Êúà', '4Êúà', '5Êúà', '6Êúà', 
                                          '7Êúà', '8Êúà', '9Êúà', '10Êúà', '11Êúà', '12Êúà'];
                    
                    // English month names
                    const englishMonths = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                                         'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                    
                    months.push({
                        key: dateKey,
                        display: japaneseMonths[month - 1],
                        english: englishMonths[month - 1],
                        year: year,
                        month: month,
                        date: date
                    });
                }
                
                this.months = months;
                console.log('üìÖ Generated months:', months);
                return months;
            }

            // Load user authentication
            async loadUserInfo() {
                try {
                    const response = await fetch('/forecast/api/user-info');
                    if (response.ok) {
                        const userInfo = await response.json();
                        this.currentUser = userInfo;
                        this.userPermissions = userInfo.permissions;
                        
                        this.updateUIForPermissions();
                        document.getElementById('current-user').textContent = userInfo.username;
                        
                        return userInfo;
                    } else {
                        console.log('‚ùå User not authenticated, redirecting to login');
                        window.location.href = '/';
                        return null;
                    }
                } catch (error) {
                    console.error('Error loading user info:', error);
                    this.showMessage('Failed to load user information', 'error');
                    return null;
                }
            }

            updateUIForPermissions() {
                const adminElements = document.querySelectorAll('.admin-only');

                if (!this.userPermissions.canEdit) {
                    adminElements.forEach(element => {
                        element.classList.add('disabled');
                        if (element.tagName === 'BUTTON') {
                            element.disabled = true;
                        }
                    });
                } else {
                    adminElements.forEach(element => {
                        element.classList.remove('disabled');
                        if (element.tagName === 'BUTTON') {
                            element.disabled = false;
                        }
                    });
                }
            }

            // Load forecast data
            async loadForecastData() {
                try {
                    this.showLoading(true);
                    
                    const response = await fetch('/forecast/api/forecasts');
                    
                    if (response.status === 401) {
                        this.showMessage('Session expired. Please log in again.', 'error');
                        setTimeout(() => window.location.href = '/', 2000);
                        return;
                    }
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const forecasts = await response.json();
                    console.log('üìä Raw forecast data from API:', forecasts);
                    
                    // Convert array to object using actual date format
                    this.forecastData = {};
                    forecasts.forEach((forecast) => {
                        const key = `${forecast.drawing_number}-${forecast.month_date}`;
                        const quantity = parseInt(forecast.quantity) || 0;
                        this.forecastData[key] = quantity;
                    });
                    
                    console.log('üìä Processed forecast data:', this.forecastData);
                    
                    this.initializeTabs();
                    this.clearChangedCells();
                    
                } catch (error) {
                    this.showMessage('Failed to load forecast data: ' + error.message, 'error');
                    console.error('Error loading forecast data:', error);
                } finally {
                    this.showLoading(false);
                }
            }

            // Initialize product tabs
            initializeTabs() {
                this.generateMonths();
                
                const tabsContainer = document.getElementById('productTabs');
                const contentsContainer = document.getElementById('tabContents');
                
                // Clear existing content
                tabsContainer.innerHTML = '';
                contentsContainer.innerHTML = '';
                
                // Create tabs and content for each product
                this.products.forEach((product, index) => {
                    // Create tab button
                    const tabButton = document.createElement('button');
                    tabButton.className = `product-tab ${index === 0 ? 'active' : ''}`;
                    tabButton.onclick = () => this.switchToProduct(product.code);
                    tabButton.innerHTML = `
                        <span class="tab-code">${product.code}</span>
                        <span class="tab-name">${product.name}</span>
                    `;
                    tabsContainer.appendChild(tabButton);
                    
                    // Create tab content
                    const tabContent = document.createElement('div');
                    tabContent.className = `tab-content ${index === 0 ? 'active' : ''}`;
                    tabContent.id = `tab-${product.code}`;
                    tabContent.innerHTML = this.generateTabContent(product);
                    contentsContainer.appendChild(tabContent);
                    
                    if (index === 0) {
                        this.activeProductCode = product.code;
                    }
                });
                
                // Update summary for active tab
                this.updateProductSummary(this.activeProductCode);
            }

            // Generate content for a product tab
            generateTabContent(product) {
                const productData = this.getProductForecastData(product.code);
                
                return `
                    <div class="product-summary">
                        <div class="product-info">
                            <div class="product-details">
                                <h3>${product.code}</h3>
                                <p>${product.name} - Monthly Forecast Planning</p>
                            </div>
                        </div>
                        <div class="product-stats" id="stats-${product.code}">
                            <div class="stat-item">
                                <div class="stat-number" id="total-${product.code}">0</div>
                                <div class="stat-label">Total Forecast</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-number" id="next-month-${product.code}">0</div>
                                <div class="stat-label">Next Month</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-number" id="avg-${product.code}">0</div>
                                <div class="stat-label">Monthly Average</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-number" id="changes-${product.code}">0</div>
                                <div class="stat-label">Unsaved Changes</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="forecast-table">
                        <table>
                            <thead>
                                <tr>
                                    <th>Forecast Period</th>
                                    ${this.months.map(month => `
                                        <th class="month-header">
                                            <div class="month-japanese">${month.display}</div>
                                            <div class="month-english">${month.english} ${month.year}</div>
                                            <div class="month-date">${month.key}</div>
                                        </th>
                                    `).join('')}
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>Quantity</strong></td>
                                    ${this.months.map(month => {
                                        const key = `${product.code}-${month.key}`;
                                        const value = this.forecastData[key] || 0;
                                        
                                        return `
                                            <td>
                                                <input type="number" 
                                                       class="forecast-input" 
                                                       value="${value > 0 ? value : ''}"
                                                       data-product="${product.code}"
                                                       data-date="${month.key}"
                                                       data-key="${key}"
                                                       placeholder="0"
                                                       min="0"
                                                       ${!this.userPermissions.canEdit ? 'disabled' : ''}
                                                       onchange="forecastManager.onCellChange(this)"
                                                       onblur="forecastManager.onCellBlur(this)">
                                            </td>
                                        `;
                                    }).join('')}
                                </tr>
                            </tbody>
                        </table>
                    </div>
                `;
            }

            // Switch to a specific product tab
            switchToProduct(productCode) {
                // Update tab buttons
                document.querySelectorAll('.product-tab').forEach(tab => {
                    tab.classList.remove('active');
                });
                document.querySelector(`[onclick*="${productCode}"]`).classList.add('active');
                
                // Update tab content
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                document.getElementById(`tab-${productCode}`).classList.add('active');
                
                this.activeProductCode = productCode;
                this.updateProductSummary(productCode);
            }

            // Get forecast data for a specific product
            getProductForecastData(productCode) {
                const productData = {};
                this.months.forEach(month => {
                    const key = `${productCode}-${month.key}`;
                    productData[month.key] = this.forecastData[key] || 0;
                });
                return productData;
            }

            // Update summary for a specific product
            updateProductSummary(productCode) {
                const productData = this.getProductForecastData(productCode);
                const values = Object.values(productData);
                
                const total = values.reduce((sum, val) => sum + (val || 0), 0);
                const nextMonth = values[1] || 0; // Next month after current
                const average = total > 0 ? Math.round(total / 12) : 0;
                
                // Count changes for this product
                let changes = 0;
                this.changedCells.forEach(key => {
                    if (key.startsWith(productCode + '-')) {
                        changes++;
                    }
                });
                
                // Update UI
                const totalEl = document.getElementById(`total-${productCode}`);
                const nextMonthEl = document.getElementById(`next-month-${productCode}`);
                const avgEl = document.getElementById(`avg-${productCode}`);
                const changesEl = document.getElementById(`changes-${productCode}`);
                
                if (totalEl) totalEl.textContent = total.toLocaleString();
                if (nextMonthEl) nextMonthEl.textContent = nextMonth.toLocaleString();
                if (avgEl) avgEl.textContent = average.toLocaleString();
                if (changesEl) changesEl.textContent = changes;
            }

            // Handle cell value changes
            onCellChange(input) {
                const key = input.dataset.key;
                const productCode = input.dataset.product;
                const value = parseInt(input.value) || 0;
                
                // Mark as changed
                input.classList.add('changed');
                this.changedCells.add(key);
                
                // Update local data
                this.forecastData[key] = value;
                
                // Update summary for current product
                this.updateProductSummary(productCode);
                this.updateSaveStatus('unsaved', 'Unsaved changes');
            }

            onCellBlur(input) {
                // Optional: Auto-save logic here
            }

            // Save all forecast changes
            async saveAllForecasts() {
                if (!this.userPermissions.canEdit) {
                    this.showMessage('You do not have permission to save changes', 'error');
                    return;
                }

                if (this.changedCells.size === 0) {
                    this.showMessage('No changes to save', 'warning');
                    return;
                }

                try {
                    this.updateSaveStatus('saving', 'Saving...');
                    this.showLoading(true);
                    
                    const forecasts = [];
                    this.changedCells.forEach(key => {
                        const lastDashIndex = key.lastIndexOf('-');
                        
                        if (lastDashIndex === -1) {
                            console.error(`‚ùå Invalid key format: ${key}`);
                            return;
                        }
                        
                        const drawingNumber = key.substring(0, lastDashIndex);
                        const monthDate = key.substring(lastDashIndex + 1);
                        
                        forecasts.push({
                            drawing_number: drawingNumber,
                            month_date: monthDate,
                            quantity: this.forecastData[key] || 0
                        });
                    });

                    console.log('üíæ Forecast data to save:', forecasts);

                    const response = await fetch('/forecast/api/forecasts/batch', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ forecasts })
                    });

                    const result = await response.json();

                    if (result.success) {
                        this.showMessage(`Saved ${result.saved} forecast entries successfully`, 'success');
                        this.clearChangedCells();
                        this.updateSaveStatus('saved', 'All changes saved');
                        
                        // Update all product summaries
                        this.products.forEach(product => {
                            this.updateProductSummary(product.code);
                        });
                    } else {
                        this.showMessage(result.error || 'Failed to save forecasts', 'error');
                        this.updateSaveStatus('error', 'Save failed');
                    }
                } catch (error) {
                    this.showMessage('Failed to save forecasts: ' + error.message, 'error');
                    this.updateSaveStatus('error', 'Save failed');
                } finally {
                    this.showLoading(false);
                }
            }

            // Clear all data
            async clearAllData() {
                if (!this.userPermissions.canEdit) {
                    this.showMessage('You do not have permission to clear data', 'error');
                    return;
                }

                if (!confirm('‚ö†Ô∏è DANGER: This will clear ALL forecast data.\n\nAre you sure?')) {
                    return;
                }

                try {
                    this.showLoading(true);
                    
                    const response = await fetch('/forecast/api/forecasts/clear', {
                        method: 'DELETE'
                    });

                    const result = await response.json();

                    if (result.success) {
                        this.showMessage('All forecast data cleared successfully', 'success');
                        
                        // Clear local data and regenerate tabs
                        this.forecastData = {};
                        this.clearChangedCells();
                        this.initializeTabs();
                        this.updateSaveStatus('saved', 'Data cleared');
                    } else {
                        this.showMessage(result.error || 'Failed to clear data', 'error');
                    }
                } catch (error) {
                    this.showMessage('Failed to clear data: ' + error.message, 'error');
                } finally {
                    this.showLoading(false);
                }
            }

            // Refresh data
            async refreshForecastData() {
                try {
                    this.showMessage('Refreshing forecast data...', 'info');
                    await this.loadForecastData();
                    this.showMessage('Forecast data refreshed successfully', 'success');
                } catch (error) {
                    this.showMessage('Failed to refresh data: ' + error.message, 'error');
                }
            }

            // Clear changed cells tracking
            clearChangedCells() {
                this.changedCells.clear();
                
                const inputs = document.querySelectorAll('.forecast-input.changed');
                inputs.forEach(input => {
                    input.classList.remove('changed');
                });
            }

            // Update save status
            updateSaveStatus(status, message) {
                const saveStatus = document.getElementById('saveStatus');
                if (saveStatus) {
                    saveStatus.textContent = message;
                    saveStatus.className = 'save-status ' + status;
                }
            }

            // Utility methods
            showLoading(show) {
                const loading = document.getElementById('loadingIndicator');
                if (loading) {
                    loading.style.display = show ? 'block' : 'none';
                }
            }

            showMessage(message, type) {
                const container = document.getElementById('messageContainer');
                if (!container) return;

                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${type}`;
                messageDiv.textContent = message;
                
                container.appendChild(messageDiv);
                
                setTimeout(() => {
                    if (messageDiv.parentNode) {
                        messageDiv.parentNode.removeChild(messageDiv);
                    }
                }, 5000);
            }

            async logout() {
                try {
                    await fetch('/forecast/api/logout', { method: 'POST' });
                    window.location.href = '/';
                } catch (error) {
                    console.error('Logout error:', error);
                    window.location.href = '/';
                }
            }

            async showDebugInfo() {
                console.log('üîç DEBUG INFO:');
                console.log('üìä Forecast data:', this.forecastData);
                console.log('üìÖ Months:', this.months);
                console.log('üè∑Ô∏è Products:', this.products);
                console.log('‚ö†Ô∏è Changed cells:', Array.from(this.changedCells));
                
                alert(`Debug Info:
üìä Forecast entries: ${Object.keys(this.forecastData).length}
üìÖ Months: ${this.months.length}
üè∑Ô∏è Products: ${this.products.length}
‚ö†Ô∏è Changed cells: ${this.changedCells.size}
üë§ Active product: ${this.activeProductCode}

Check console for detailed logs.`);
            }

            // Initialize
            async initialize() {
                try {
                    console.log('üöÄ Initializing Tabbed Forecast Manager...');
                    
                    await this.loadUserInfo();
                    await this.loadForecastData();
                    
                    console.log('‚úÖ Forecast Manager initialized successfully');
                } catch (error) {
                    console.error('‚ùå Failed to initialize forecast manager:', error);
                    this.showMessage('Failed to initialize forecast manager', 'error');
                }
            }
        }

        // Create global instance
        const forecastManager = new ForecastManager();

        // Global functions
        function saveAllForecasts() {
            forecastManager.saveAllForecasts();
        }

        function clearAllData() {
            forecastManager.clearAllData();
        }

        function refreshForecastData() {
            forecastManager.refreshForecastData();
        }

        function logout() {
            forecastManager.logout();
        }

        function showDebugInfo() {
            forecastManager.showDebugInfo();
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            forecastManager.initialize();
        });
    </script>
</body>
</html>